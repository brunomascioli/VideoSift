 While back I posted a message here on YouTube asking you to share some of the coolest Python libraries that are using and that you think more people should know about. So today I'm going to share 15 libraries that are really awesome. I'm sure that's least a few that you don't know about. His libraries can make your life easier. Your code is the read and your projects more fun. Yes! So let's dive in. First, the library that I want to talk about is penulom and this is a really cool utility to help you deal with dates and times. Actually dealing with dates and times can be really a pain with different times on daylight savings, leave here, etc etc etc. So what penulom actually does is it provides you with an easy interface to deal with date and times and also competitions of dates and times like computing and computing differences between dates and things like that. It's really easy to manipulate dates and times. For example, here you see that you can define a particular date in Europe Paris and then you can change the time zone and very easily you can convert it to different dates and formats depending on your need. You can shift by adding dates and things like that. What's cool about penulom is that it offers human readable dates. Like what you see here, for example, or you can even do that for dates and time differences. Like this. And being a human myself, I really appreciate this. Next library I want to talk about is pi PDF. And this is a free open source Python PDF library. Pi PDF can read PDF, can split them, merge them, it can even add custom data or watermarks. And you can even add passwords to your PDF files, which is really neat. I like this library a lot because the last week to automate work where I have to deal with PDFs, think of contracts or invoices and pi PDF can handle those with ease. Next library is ice cream. Now, I don't know why this is called ice cream. I haven't figured that out yet. If you have an idea why it's called like that, post it in the comments, but ice cream is a library to make debugging easier. And what's really nice about this? Well, apart from the beautiful image right here obviously, is that instead of using prints to debug or log, you can actually use ice cream and you write simply ice cream. So it's also a bit shorter. And what's nice about this is that the output is syntax highlighted. And that is actually really cool. And the second thing that it does is that it actually inspects itself. So normally if you would use prints and you would print the result of a function like so, then you would just get the result. Right? But what ice cream does that it actually inspects the argument. So if you have this example, it's not just going to print the result of that particular function call, but it's actually also going to print the function and the arguments that will pass the function. So this is incredibly useful for debugging. And it also does that for data types. In this case, we have a dictionary. And if you print the dictionary, then you can also see what is actually being printed or if you have a class with an attribute. And it also prints the name of the class and the name of the attributes. So we use an ice cream for debugging. You just save a bunch of time printing very nice. Really easy. Next library is log guru. I hope I'm pronouncing that correctly. This is a library for logging, but simplified. One thing in particular that simplifies that you don't have to create a logger object. You can simply import a logger from log guru and then use that. So that makes it almost as easy to use as just a simple print statement. What's nice about log guru is that it has some built in things that are really neat, such as being able to automatically add colors to a log if you're terminal support. You can simply define your favorite style. We use markup tags and then that actually works. That's all the things as well, such as being able to deal with daytime, better than the standard logging package. And also has built in functionality to more easily view the entire stack trace. By the way, if you're enjoying these libraries so far, you might also be interested in joining my free weekly newsletter. In newsletter, I share the latest news from the Python world as well as some other content that I don't share on the YouTube channel. Just go to rmco.com to subscribe for free. If you don't like it, you can unsubscribe at any time. Next library that I want to talk about is rich, and this is a Python library to write rich text with color and style to the terminal. What I really like about rich is that it can actually render markdown. So you can write your markdown text and then it can write that to the console. And then it's going to be styled nicely. And this even renders code blocks in markdown with full syntax highlighting. So it's really cool. It can do way more things like, for example, displaying tables. It can show a progress display. And you can even do some basic styling like adding padding. The next library I want to talk about is art pars. And this is actually the only standard library that I'm including in this list. Art pars, I've been using myself quite a lot to build simple command line interface. And it's really powerful for that. It has really a lot of capabilities. Basically with just a few lines of code, you can create a command line interface with a name description, a help page. It's very easy to add arguments. I don't position or an option that expects value. Then you can simply parse them and use them in your Python script. Next library is TQDM, which apparently means progress in a rabbit. I didn't know that. And it's even an abbreviation for I love you so much in Spanish. What TQDM does is that it gives you a progress path, which is very helpful. And you can link this progress bar with anything that's happening in your code. For example, processing a permus, data frame, or collecting data from the internet, or anything that you need to do that requires monitoring the progress. It's super lightweight and it easily integrates with a wide variety of projects. I'm just wondering how many of you are actually building command line interfaces regularly. And what do you typically use them for? Let me know in the comments. Next library I want to talk about is X array. And this is sort of a pandas.com for multi-dimensional arrays. And this is designed to make working with multi-dimensional label data easily and fun. If you somehow think that dealing with multi-dimensional data is fun, which I'm not really sure that it is. So what can use this for? Well, it's great for scientific computing data analysis. These kinds of things. It also interoperates very well with the scientific Python ecosystem, like non-pi and Tomas and MAPLOADLIP. X array has a lot of feature like, for example, possibility to interpolate data. You can group and bin data. And you also have very good support for multi-dimensional time series data. So if you're dealing with complex multi-dimensional data, X array is really good choice for you. Next up is Polars. And this is a data frame library that's really optimized for speed. It's written in Rust, but you can also use it in Python. And it's going to use that same, performant engine underlying both of these implementations. Polars isn't particularly helpful if you deal with really large data sets, because it can handle those much better than something like pandas. It's blazingly fast. It can also be used with multi-threading. So this is a great choice for heavy computational tasks. Next is C-born, which is a library for statistical data visualization. So this is built on top of MAPLOADLIP. And the nice thing about this is that it can create these beautiful looking charts and graphs. Very easily without them to provide tons and tons of options. So it comes out of the box with a nice style. If you want to plot something you just provide the data and a couple of settings, depending on what you want, but it's really limited and you're going to get beautiful charts automatically. What's nice about C-born is that it has themes and color pellets. For example, if you have a function like this and then plot that with MAPLOADLIP, then you're going to get something that looks like this. With C-born, you simply set a theme and then it's going to already look a lot better. But then you can actually choose different themes. For example, here's a dark style. There's a white style. There's a ticks style. So it has a lot of different options. You can even choose different color pellets so that the charts and graphs are so easily fit within the style of your application. The next library that I want to mention is Result. This is kind of an outlier because it's a pretty basic idea. But the idea of Result is that it allows you to do so-called railroad oriented programming. And I talked about that in a video a long time ago, which if you want to watch that, I'll put a link at the top. But the idea is that this is an alternative to handling errors using exceptions. So, normally, what most people would do is that if you have a problem in your program like you can't find file or something, or network connection closes or whatever, or your input values are wrongly formatted, you've raised an error, right? And you use Python's exception framework for that. Not everybody likes that because that creates sort of a control flow that's outside of your main program. An alternative way of doing that, and this one idea that comes from the functional program I'm going to main, instead of returning just a result value and optionally raising an error, that you actually have a result value that can either be okay. And in that case, you get the value, or it can be an error. And in that case, you get an error. So, that leads to like two parallel paths in your function calling, and that's why it's also called railroad oriented programming. And then basically, as long as everything's fine, you just on the OK path, but as soon as there's a problem, well, then you go to the error path. And the result library provides some tooling and types to help you do that more easily. So, there's a result type that gets basically the value that you expect from this particular function, and an error value in this case uses a string, and then in the code itself is simply handle those cases. So, for example, if there is no user, then we're going to return an error. If the user is not active, we're also going to return the error, and otherwise we're going to return the actual user. And then you can use an F statement to check which of these things you have to deal with. And if using a recent version of Python, then you can even use match case statements to deal with the different types of returns that you could get from this function. Now, do think that it would be even better if this wasn't integrated more into the language itself. But if you don't like exceptions, then this might be a nice option for you. Next one, this library you probably know is called Puyagantic, and Puyagantic is a really cool data validation library for Python. You can use this to validate data on the fly and basically catch errors before they become bugs in your program. What's cool about this is that Puyagantic is used by quite a few different libraries in the Python ecosystem, and also works well with type annotations. So, one library in particular, that it works really well with is fast API, and that's actually the next library on our list, which you probably also know. Now, fast API is modern web framework for building back in APIs with Python. It's really easy to get started with it. I much prefer fast API overflask, because I think it has just better tooling, and overall there's more support for modern Python features. For example, it supports concurrency and async, oh wait, out to the box. It also uses type annotations to define return types for the API and uses that also for validation of input arguments. And what's really cool about fast API is that it automatically serves a documentation side using either the swagger UI or redock. If you're building a full application, a tool like fast API is just one of the tools you probably need. If you're learning more about how to design a complete application from scratch, I have a free guide for you. You can get this at arion.coldsslashdesign guide. This contains the seven steps that I take, whatever I design, a new piece of software, and hopefully it helps you avoid some of the problems that I made in the past. So, arion.coldsslashdesign guide to get your copy for free. Just enter your email address and you'll get it in your inbox. I will split the link in the description of the video. Next library that I want to mention that integrate really well with fast API is SQL model. And this is built on both by Dantic and SQL alchemy. SQL model is an over-emmon object relational mapping library. And that allows you to use objects, classes, and methods to manipulate objects in the database. So this allows you to connect your fast API applications to databases like SQLite, MySQL, and more. And what's really cool about this is that this is built on similar ideas as fast API. So it's uses modern Python type annotations in particular. So you don't need to learn any new syntax. And the way that this is set up is really intuitive. You can simply define a class that inherits from SQL model. So this defines the table and you provide the fields that should be in the table. And one thing that's also nice about SQL model is that it has an easy way to define relationships. He's seen example of a team table and a hero table. A hero is part of team. So it has a team ID. And we can indicate right in the model that this ID is a foreign key and refers to the ID of a team. But the stones of all the features in SQL model as well. If you want me to do a full video about this, let me know in the comments. Final library I want to talk about is HTTP X. If you've used requests, you know that there are some limitations, especially when dealing with asynchronous requests. The request package that's really supported all that well. Now HTTP X is a next generation HTTP client and this supports a ton of extra features. For example, it has a sync support. It's also fully type annotated. You can do lots of things including pulling connections, streaming. It has lots of features. Before I finish the video, I just want to give you a bonus library. And that is Python.nf. I use Python.nf all the time application to read key value pairs from a.n file. Then I can simply access them using environment variables in my code. Of a lot about that is that it gives me a lot of flexibility. And that I have lots of ways in which I could provide environment variables when running my code. So for example, if I run it in a cloud, I might decide to define those environment variables. Some girls in my code will still work. And locally, I can work with a.nf with the right key value pairs. Or I could even run the application in different contexts simply by switching the.nf or the values in the.nf. And finally, this also promotes that you shouldn't put those things directly in your code. But put them in a different place for security purposes. So I hope you enjoyed this list. If you have any other suggestions for libraries that are interesting to people, just post them in the comments below. So for some of the libraries I mentioned, I have more in depth video on my channel. For example, fast API. If you're not using that and yet definitely shoot and you can watch this video next to get all the details about how to use it. Thanks for watching and take care.